// Язык C++ основан на языке Си. Всё, что описано в файле "Си для чайников", подойдёт и для языка C++.

#include <iostream> /* Одна из ключевых библиотек, которую нужно вызвать
для использования определённых функций (напр., cin или cout). Аналог <stdio.h> из Си. */
#include <string> // Эта библиотека позволяет нам проводить различные операции со строками.
#include <vector> // Эта библиотека позволяет нам работать с векторами (вектор - это динамический массив).

using namespace std; /* Ключевое слово namespace используется
для объявления области действия, которая содержит набор связанных объектов.
Например, using namespace std сообщает компилятору, что мы хотим использовать всё, что находится в пространстве имен std.
Можно написать перед функцией main или внутри неё, используя std перед каждой функцией из области действия (напр., std::cout) */

int main() { // С функции main начинается каждая программа в языке C++

    cout << "Hello, World!" << endl; // Вывод строки.

    { // Переменные

        /* Объявление переменной:
         * Тип переменной, потом название переменной, затем можно либо
         * присвоить этой переменной значение (=) - это называется копирующей инициализацией или определением, либо
         * закрыть строку (;), тем самым просто запомнив эту переменную - это называется инициализацией по умолчанию.
         * После этого с этой переменной можно производить любые операции. */
            int num;
            int num_first = 1;

        // Также можно определять переменные через прямую инициализацию (во встроенных типах не отличается от копирующей):
            int number(123); // В number запишется 123.

        // Типы данных
        // int - целочисленный тип данных
            num_first = 6;
        // short - также целочисленный тип данных, но с меньшим диапазоном (от -32768 до 32768), зато использует в 2 раза меньше памяти
            short sh = 32000;
        // Также есть long (и ещё long long), который имеет в разы больший диапазон, нежели int, но и памяти также использует в 2 раза больше
            long ln = 126379781;

        /* К переменным с целочисленным типом можно приписывать unsigned, что лишает переменную всех отрицательных значений,
         * но использует столько же памяти (т.е. диапазон в положительную сторону увеличивается). */

        // float - вещественный тип данных (число с плавающей точкой), точность - 7 разрядов
            float num_float = 1.012393f; // В float можно на конце писать f, но необязательно
        // double - также вещественный тип данных, но с большей точностью (15 разрядов)
        // Также есть long double, имеющий точность 21 разряд

        // char - символьный тип данных (можно поместить только один символ)
            char c = 'c'; // При переменной типа char символ нужно помещать именно в одинарные кавычки (')

        // bool - булевый тип данных, имеющий только 2 значения - true и false
            bool fls = false;
        // Вместо true и false можно использовать 1 и 0 соответственно

        // Можно объявлять сразу несколько переменных:
            int x, y, z;
            int p = 10, q = 9, r, t;

        // Можно задавать константы (постоянные):
            const int c = 1;
        // Но! Потом будет нельзя присваивать к этой переменной другие значения! (На то она и константа)
            c = 3; // Нельзя!

        // С типами int и float (вещественный тип данных) можно производить различные математические операции:
            r = p + q;

        // Производить можно + (сложение), - (вычитание), * (умножение), / (деление), % (остаток от деления).

        /* Производя вычисления над одной и той же переменной, можно сокращать синтаксис:
        * x = x + 5 это то же самое, что и x += 5.
        * ++ - прибавление к переменной единицы (+1), инкремент (аналогично, -- - декремент, уменьшение на 1).
        * Инкременты и декременты можно использовать как перед переменной, так и после неё, но есть отличия. */

            int x = 5;
            int y = ++x; // x = 6 и 6 присваивается переменной y

            int x = 5;
            int y = x++; // x = 6, но переменной y присваивается 5

    }

    { // Ввод и вывод символов

        // cout - функция вывода
            cout << "there!" << endl; // Выведется there!
            // endl - конец строки. Равносильно "\n", "\0" и т.д..

            // Можно вывести несколько строк:
                cout << "Hello" << " " << "there!"<< endl; // Выведется "Hello there!"

        // cin - функция ввода
            int lol1, lol2;
            cout << "Enter lol1:" << endl;
            cin >> lol1;
            cout << "Enter lol2:" << endl;
            cin >> lol2;

    }

    { // Условные операторы

        // Как используется условный оператор if:
            int x = 5;
            if(x == 5) { /* Идёт проверка условия.
                         * Если условие истинно, выполнится тело условия.
                         * Если условие ложно, то тело условия не выполнится. */
                cout << "x равно 5" << endl;
            } else if(x > 5) { // Дополнительная проверка, которая выполняется в том случае, если if не выполнилось.
                cout << "x больше, чем 5" << endl;
            } else { // else выполняется только в том случае, если if и все else if не выполнились.
                cout << "x меньше, чем 5" << endl;
            } // else и else if пишутся после if (если else или else if используются). else if всегда помещается между if и else.

            // Если в теле условия используется всего одна строка, фигурные скобки ({}) можно не использовать.

            // Также можно использовать новое условие в теле другого условия:
                if(x >= 5) {
                    if (x == 5)
                        cout << "Yes" << endl;
                    else
                        cout << "No" << endl;
                }

        // Все операторы сравнения: == (равно), != (не равно), < (меньше), > (больше), <= (меньше или равно), >= (больше или равно)
        // Логические операторы: || (логическое ИЛИ), && (логическое И), ! (логическое НЕ)

        // Условные операторы также позволяют работать с булевыми значениями:
            bool istrue = true;
            bool isfalse = false;
            if (istrue && !isfalse) cout << "Hi!" << endl;
                /* Тело будет выполняться, если булево значение истинно (при ! - ложно),
                 * причём достаточно просто написать название булевой переменной. */
            else cout << "Bye!" << endl;

        // Тернарный оператор (укороченая запись типа if..else..)
            int num = 1 == 1 ? 10 : 20; /* Если условие (в данном случае 1 == 1) истинно,
            то переменной num присваивается значение 10, иначе присваивается значение 20 */

        // Оператор принятия решений switch-case
            int x = 6;
            switch(x) { // В switch-case можно проверять только на точное совпадение значений.
                case 5:
                    cout << "5" << endl;
                    break; // Проверяет от case до break, т.е. следующие case уже не проверяются.
                case 9:
                    cout << "9" << endl;
                    break;
                case 2:
                    cout << "2" << endl;
                    break;
                default: // default сработает в том случае, если каждый из case не был выполнен.
                    cout << "ok" << endl;
                    break;
                    // switch-case намного короче и удобнее для проверки определённой переменной на соответствие различным значениям.
            }

    }

    { // Массивы

        // Объявление массива:
            /* Сначала указываем тип всех элементов массива,
            * затем называем массив,
            * после этого в квадратных скобках пишем количество элементов в массиве.
            * Также можно сразу присвоить каждому элементу значение, это делается за счёт фигурных скобок - это называется агрегатной инициализацией.
            * Если сразу присваиваем значения элементам, необязательно писать количество элементов в квадратных скобках. */
                int arr[] = {1, 3, 5, 7, 9};

        // Отсчёт по элементам в массиве начинается с 0, т.е. 1 элемент имеет индекс [0] и т.д.
            cout << arr[2] << endl; // Выведет 3 элемент, т.е. 2

        // Можно и переприсвоить значение элементу массива:
            arr[2] = 2;

        // Двумерный массив
            int array[3][4] = {
                    {4, 5, 6, 7},
                    {7, 8, 9, 10},
                    {4, 6, 8, 10}
            }; /* Двумерный массив - своеобразная матрица из различных элементов, выстроенная в столбцы и ряды.
                * В двумерных массивах обязательно надо обозначать размерность.
                * Первая скобка отвечает за то, сколько маленьких массивов будет внутри большого (двумерного) массива.
                * Вторая скобка отвечает за то, сколько элементов будет в маленьких массивах.
                * Работа с двумерными массивами почти не отличается от работы с обычными, надо просто писать два аргумента. */
            // Также существуют трёхмерные и четырёхмерные массивы (и т.д.).

    }

    { // Векторы (работает при подключении библиотеки <vector> и при использовании пространства имён std)

        /* Векторы - это динамические массивы,
         * т.е. если массив мы можем заполнить элементами только до того количества элементов, которое мы изначально указали,
         * то вектор мы можем растянуть,
         * т.е. по ходу можем добавить дополнительные элементы, выходящие за предел ранее указанного количества. */

        vector <int> vector1(10);

        // Можно поместить элемент или массив в вектор, используя функцию insert():
            vector1.insert(vector1.begin(), 10); // Добавляем в начало вектора vector1 элемент со значением 10

            int arr[] = {1, 2, 3, 4};
            vector1.insert(vector1.begin(), arr, arr + 3); // Добавляем в начало вектора vector1 элементы с первого по третий массива arr.

        /* Функцию insert() вектора можно использовать по-разному для разных целей.
         * Ниже указаны три разных синтаксиса этой функции. */ {

            iterator insert(const_iterator position, const value_type &value);
            /* Вышеупомянутая функция insert() используется для вставки значения аргумента value перед позицией элемента вектора,
             * упомянутого аргументом position. Он возвращает итератор, указывающий на вновь вставленный элемент вектора. */

            iterator insert(iterator position, size_type n, const value_type &value);
            /* Вышеупомянутая функция insert() будет работать аналогично функции insert(), упомянутой ранее,
             * но она будет вставлять одно и то же значение несколько раз в векторный объект. */

            iterator insert(const_iterator position, InputIterator first, InputIterator last);
            /* Вышеупомянутая функция insert() будет вставлять диапазон элементов перед позицией элемента вектора,
             * упомянутого аргументом позиции. Он возвращает итератор,
             * который указывает на вновь вставленные элементы вектора, как и две предыдущие функции insert(). */
        }

        // Также можно вставлять элемент в конец вектора, используя функцию push_back():
            vector1.push_back(45);

        // Можно вывести элемент вектора:
            cout << vector1.at(1) << endl; // На месте аргумента функции at() пишем индекс элемента вектора, который мы хотим вывести.
            cout << vector1.front() << endl; // Выведется первый элемент вектора.
            cout << vector1.back() << endl; // Выведется последний элемент вектора.

    }

    { // Строки (работает при подключении библиотеки <string> и при использовании пространства имён std)

        // Как работают "строки" на Си:
        char word[] = {'S','o','m','e'}; // То же самое, что и:
        char words[] = "Some"; // В строках используем обязательно двойные кавычки (").
        // Проще говоря, это массив символов.

        // На C++ появилась возможность использовать строки как отдельный тип данных:
        std::string some = "Some";
        cout << some << endl; // Выведется "Some".

        // Строки можно конкатенировать:
        string one = "One";
        string two = "Two";
        cout << one + two << endl; // Выведется "OneTwo".

    }

    { // Циклы

        // Цикл с параметром for:
            for(int i = 0; i < 10; i++) { /* В цикле for используется 3 операции внутри скобок:
                                           * Первая операция отвечает за инициализацию
                                           * (обозначаем переменную-параметр, который будет использоваться в цикле)
                                           * Эта переменная будет использована только в цикле и не будет запомнена в самой программе.
                                           * Вторая операция отвечает за условие
                                           * (цикл будет работать, пока условие выполняется (т.е. является истинным)).
                                           * Третья операция отвечает за модификацию
                                           * (как будет изменяться значение переменной-параметра). */
                cout << i << endl;
            } // Этот цикл выведет в консоль все числа от 0 до 9.

        // Цикл с условием while:
            bool t = true;
            int x;
            while(t) { // В цикле while используется 1 операция внутри скобок - условие.
                cin >> x;
                if(x == 1)
                    t = false;
            } // Этот цикл закончится, если в консоли ввести число 1.

        // Как из цикла while можно сделать цикл for:
            int i = 0;
            while(i < 10) {
                cout << i << endl;
                i++;
            } // Этот цикл аналогичен тому, что я написал выше, где описывал цикл с параметром.

        // Цикл с условием do-while:

            /* Отличие цикла do-while от цикла while в том, что
             * цикл do-while сначала выполняет тело цикла, а затем проверяет условие, а не наоборот, как в случае с while. */

            bool f = false;
            do {
                cout << "Hi" << endl;
            } while(f);// Этот цикл выполнится 1 раз, т.к. условие не выполняется.

        // Операторы внутри циклов:
            for(int x = 0; x < 10; x++) {
                if(x == 5)
                    break; // Оператор break незамедлительно завершает цикл, игнорируя последующие строки кода в теле цикла.
                if(x % 2 == 0)
                    continue; /* Оператор continue пропускает одну итерацию в цикле,
                               * т.е. игнорирует последующие строки кода в теле цикла, перемещаясь к следующему оператору.
                               * Например, в данном случае цикл будет пропускать все чётные числа. */
                cout << x << endl;
            } // На экран выведутся числа 1 и 3.

        // С массивами также можно производить различные операции в циклах:
            int array[] = {3, 0, 9, 10, -90, -24};
            for(int i = 0; i < 6; i++)
                cout << array[i] << endl;

            int min = array[0];
            for(int i = 0; i < 6; i++) {
                if(array[i] < min)
                    min = array[i];
            }

        // И с векторами:
            vector<int> _vector;
            for(int i = 0; i < 10; i++) {
                _vector.insert(_vector.begin(), i);
            }

        // И со строками:
            string str = "Hello world";
            for(int i = 0; i < str.size(); i++) {
                cout << str[i];
            }

    }

    { // Функции

        // Функции - это подпрограммы, в которые можно вносить повторяющийся код, а после этого вызывать их, выполняя код внутри функции.

        // Чтобы создать функцию, необходимо прописать её до функции main().
            // Сначала необходимо прописать тип данных, который будет возвращён самой функцией.
                // Чтобы функция что-либо возвращала, надо указать определённый тип данных, который эта функция будет возвращать:
                    double mult(double a, double b) {
                        double res = a * b;
                        return res;
                    }
                    // Внутри main() это будет задействовано следующим образом:
                        int main() {
                            double x = 5.5, y = 9.2;
                            cout << mult(x, y) << endl;
                            return 0; /* На ключевом слове return и числе 0 заканчивается любая программа в языке C,
                                       * в которой использовалось int перед main.
                                       * return 0 необязательно использовать в конце функции main в C99 или C11, но обязательно в C89.
                                       * Также вместо int main можно использовать void main. */
                        };

                // Если функция ничего не возвращает, то тип данных указывается void.
                    void info() {
                        cout << "Привет" << endl;
                    }

            // Внутри функции можно использовать свои переменные, их просто нужно задать в скобках:
                void sum(int a, int b) {
                    int res = a + b;
                    cout << res << endl;
                } // Заданные в функции переменные не будут распространяться на всю остальную программу.

                // Внутри кода переменные используются следующим образом:
                    int main() {
                        sum(20, 50);
                        int x = 9, y = 2;
                        sum(x, y);
                    } // Т.е. вместо a и b можно вставить любое число или переменную того же типа.

                // Также внутри функции можно передать и массив:
                    void hello(int arr[]) {
                        for(int i = 0; i < 10; i++) {
                            cout << arr[i] << endl;
                        };
                    }

                // И также строки:
                    void print(string word) {
                        cout << word << endl;
                    }

            // Чтобы вызвать функцию, надо внутри функции main() обратиться к функции по имени:
                int main() {
                    info();
                }

            // Чтобы функция могла принимать аргументы другого количества и других типов данных, используется перегрузка функций:
            void print(string word) {
                cout << word << endl;
            }
            void print(float term1, float term2) {
                cout << term1 + term2 << endl;
            }
            int main() {
                print("Hello World!");
                print(1.25, 1.75);
            }

            // Функцию можно прописать и после функции main, но для этого нужно обратиться к ней до функции main():
                void info(void); // Если обращаемся к функции до main и внутри неё нет параметров, надо указать в скобках void.
                int main() {
                    info();
                    return 0;
                }
                void info() {
                    cout << "Привет" << endl;
                }

            // Также функции можно прописывать при помощи заголовочных файлов:
                /* Необходимо создать заголовочный файл с расширением .h (как у библиотек),
                 * затем нужно прописать в этом файле функцию, которую мы хотим использовать,
                 * после этого этот код можно использовать и в основной программе,
                 * нужно просто до функции main написать #include "[название_файла].h" (без скобок и в двойных кавычках),
                 * а затем вызвать функцию по её названию уже внутри main. */
                    #include "functions.h"
                    int main() {
                        info();
                    }

            // Можно совершать проверки на исключения в функциях с помощью блока try-catch и оператора throw (необязательно):
                float del(float a, float b) {
                    int res;
                    try {
                        if(b != 0)
                            res = a / b;
                        else
                            throw b; // Сгенерировали исключение с помощью throw.
                    } catch(float num) {
                        cout << num; // выведется исключение, т.е. значение b, т.е. 0
                    }
                    return res;
                }
                /* В блок после ключевого слова try помещается код, который потенциально может сгенерировать исключение.
                 * Оператор throw генерирует исключение. Через оператор throw можно передать информацию об ошибке.
                 * После ключевого слова catch в скобках идет параметр, который передает информацию об исключении.
                 * Затем в блоке производится собственно обработка исключения.
                 * В качестве аргумента в catch() передаётся тот тип данных, который catch() "ловит" в качестве исключения.
                 * Т.е., если ранее throw сгенерировало исключение с типом данных float (как в вышеуказанном примере),
                 * то catch() должен принимать исключение с типом float. */

        // Встроенные функции

            /* Встроенная функция — это такая функция, чье тело подставляется в каждую точку вызова,
             * вместо того, чтобы генерировать код вызова. Это подобно использованию параметризованных макросов в С (#define ...).
             * Определяется встроенная функция за счёт использования модификатора inline.
             * Например, для создания встроенной функции f, возвращающей значение типа int и не имеющей параметров, достаточно объявить ее следующим образом: */

                inline int f() {
                    // ...
                }

            /* Причина использования встроенной функции заключается в их эффективности. Всякий раз, когда вызывается функция,
             * Необходимо выполнить серию инструкций для формирования вызова функции, вставки аргументов в стек и возврата значения из функции.
             * В некоторых случаях для этого приходится использовать много тактов центрального процессора.
             * При использовании встроенной функции нет необходимости в таких дополнительных действиях и скорость выполнения программы возрастает.
             * Однако в тех случаях, когда размер встроенной функции достаточно большой, общий объем программы также возрастает.
             * Поэтому в качестве встроенной функции обычно используются очень маленькие функции. Большие функции реализуются обычным способом. */


        // Статические переменные и функции

            /* Static - это ключевое слово в C++, используемое для придания элементу особых характеристик.
             * Для статических элементов выделение памяти происходит только один раз,
             * и существуют эти элементы до завершения программы. */

                // Статические переменные внутри функции:

                /* Статические переменные при использовании внутри функции инициализируются только один раз,
                 * а затем они сохраняют свое значение. Эти статические переменные хранятся в статической области памяти, а не в стеке,
                 * что позволяет хранить и использовать значение переменной на протяжении всей жизни программы. */

                // Cтатические переменные всегда инициализируются. Если переменной не присвоить значение, то она инициализируется нулём.

                void counter() {
                    int count = 0;
                    std::cout << count++;
                }
                void static_counter() {
                    static int count; // Эквивалентно static int count = 0;
                    std::cout << count++;
                }
                int main() {
                    for(int i = 0; i < 10; i++) {
                        static_counter(); // Выведет 0123456789
                    }
                    for(int i = 0; i < 10; i++) {
                        counter(); // Выведет 0000000000
                    }
                    return 0;
                }

                // Статические функции

                    /* Статические функции пришли в С++ из С. По умолчанию все функции в С глобальные и,
                     * если вы захотите создать две функции с одинаковым именем в двух разных .c(.cpp) файлах одного проекта,
                     * то получите ошибку о том, что данная функция уже определена. */

                    // extend_math.cpp
                    int sum(int a, int b) {
                        int some_coefficient = 1;
                        return a + b + some_coefficient;
                    }

                    // math.cpp
                    int sum(int a, int b) {
                        return a + b;
                    }

                    // main.cpp
                    int sum(int, int); // declaration
                    int main() {
                        int result = sum(1, 2);
                        return 0;
                    }

                    // Для того чтобы исправить данную проблему, одну из функций мы объявим статической. Например эту:

                    // extend_math.cpp
                    static int sum(int a, int b) {
                        int some_coefficient = 1;
                        return a + b + some_coefficient;
                    }

                    /* В этом случае вы говорите компилятору, что доступ к статическим функциям ограничен файлом, в котором они объявлены.
                     * И он имеет доступ только к функции sum() из math.cpp файла.
                     * Таким образом, используя static для функции, мы можем ограничить область видимости этой функции,
                     * и данная функция не будет видна в других файлах, если, конечно, это не заголовочный файл (.h).

                        * Как известно, мы не можем определить функцию в заголовочном файле, не сделав её inline или static,
                        * потому что при повторном включении этого заголовочного файла мы получим такую же ошибку,
                        * как и при использовании двух функций с одинаковым именем.
                        * При определении статической функции в заголовочном файле мы даем возможность каждому файлу (.cpp),
                        * который сделает #include нашего заголовочного файла, иметь свое собственное определение этой функции.
                        * Это решает проблему, но влечет за собой увеличение размера выполняемого файла,
                        * т.к. директива include просто копирует содержимое заголовочного файла в .cpp файл. */

        // Перегрузка функций

            /* Функции (а также шаблоны функций) называются перегруженными (overloaded),
             * если они объявлены в одной области видимости и имеют одно и то же имя.
             * Перегруженные функции не могут иметь разные типы возвращаемого значения,
             * спецификатор исключений или спецификатор удаленной функции (= delete) при одинаковых параметрах. */

            void Foo();
            char Foo(); // ошибка

            void Foo(int x);
            void Foo(int x) noexcept;  // ошибка
            // Спецификатор noexcept даёт гарантию того, что в коде функция точно не генерирует исключений.

            void Foo(double x);
            void Foo(double) = delete; // ошибка
            // Спецификатор delete помечает функцию как удалённую, и любое обращение к ней будет вызывать ошибку компиляции.

    }

    { // Указатели и ссылки

        // Указатель - это некоторая переменная, которая содержит адрес другого объекта. Указатели сильно оптимизируют код.
            int num = 0;
            int* ptrNum = &num; // Называем указатель (перед ним ставим *) и присваиваем ему адрес переменной, которую мы хотим использовать.
            cout << *ptrNum << endl; // Выведется значение переменной num, т.е. 0.
            cout << ptrNum << endl; // Так мы выведем адрес переменной num. То же самое, что и cout << &num << endl.
            cin >> *ptrNum; // Таким образом мы изменим значение переменной num.

            // Можно ссылаться и на адрес указателя (и т.д.):
                int** ptr_ptrNum = &ptrNum; // То же самое, что и int* ptr_ptrNum = ptrNum.
                cin >> **ptr_ptrNum; // Сначала в указатель ptrNum передастся значение из ptr_ptrNum, а затем из него к переменной num.

            /* В массиве указатель изначально всегда указывает на первый элемент.
             * Т.е. при использовании функции мы передаём не весь массив, а его указатель. */
                int arr1[] = {1, 3, 6, 0};
                int func_using_arr1(int* arr1);

            // Запись типа array[n] всегда эквивалентна записи *(array + n).

        // Ссылка - это особый тип данных, который является скрытой формой указателя и при использовании автоматически разыменовывается.
            int& refNum = num; // То же самое, как если бы мы написали int* ptrNum = &num.
            cout << refNum << endl; // Выведется значение переменной num, т.е. 0.
            cin >> refNum; // Таким образом мы изменим значение переменной num.

            // Нельзя передать в ссылку весь массив, но можно передать в ссылку указатель на массив:
                int arr2[] = {1, 2, 3};
                int& ref = *arr2;

        // По сути в практическом применении между указателями и ссылками особо нет разницы.

        /* Разница между указателями и ссылками:
         * Основное назначение указателей - это организация динамических объектов,
         * например, объекты, которые могут увеличиваться или уменьшаться,
         * Ссылки же предназначены для прямого доступа к тому или иному объекту.
         * Т.е. благодаря ссылке мы имеем прямой доступ к объекту,
         * а указатель как бы копирует объект и уже непосредственно как изменяется сам, так и изменяет объект, на который указывает.

         * Указатель ссылается на участок в памяти, используя адрес.
         * Ссылки же ссылаются на объект по его имени (тоже своего рода адрес). */

    }

    { // Динамическое выделение памяти

        /* В Си работать с динамической памятью можно при помощи соответствующих функций распределения памяти (calloc, malloc, free),
         * для чего необходимо подключить библиотеку stdlib.h.

         * С++ использует новые методы работы с динамической памятью при помощи операторов new и delete:
             * new - для выделения памяти;
             * delete - для освобождения памяти.

         * Оператор new используется в следующих формах:
             * new type - для переменных;
             * new type[size] - для массивов.
         * Результатом выполнения операции new будет указатель на отведенную память или исключение std::bad_alloc в случае ошибки. */

            int* ptr_i;
            double* ptr_d;
            struct Person* human;

            ptr_i = new int;
            ptr_d = new double[10];
            human = new struct Person;

         /* Память, отведенная в результате выполнения new, будет считаться распределенной до тех пор, пока не будет выполнена операция delete.

          * Оператор delete используется в следующих формах:
              * delete pointer - для одного элемента;
              * delete[] pointer - для массивов. */

            delete ptr_i;
            delete[] ptr_d;
            delete human;

    }

    { // Объектно-ориентированное программирование

        /* Объектно-ориентированное программирование (ООП) — это подход,
         * при котором программа рассматривается как набор объектов, взаимодействующих друг с другом.
         * У каждого объекта есть свойства и поведение. ООП ускоряет написание кода и делает его более читаемым.

         * Объектно-ориентированное программирование используется, чтобы:
             * 1) Структурировать информацию и не допускать путаницы;
             * 2) Точно определять взаимодействие одних элементов с другими;
             * 3) Повышать управляемость программы;
             * 4) Быстрее масштабировать код под различные задачи;
             * 5) Внедрять изменения без необходимости переписывать весь код.

         * Принципы ООП:
         * Объектно-ориентированное программирование определяют через три принципа, по которым можно понять основы работы.

             * Инкапсуляция — это свойство, позволяющее объединить в классе и данные,
             * и методы, работающие с ними, и скрыть детали реализации от пользователя.

             * Наследование — это свойство, позволяющее создать новый класс-потомок на основе уже существующего,
             * при этом все характеристики класса родителя присваиваются классу-потомку.

             * Полиморфизм — свойство классов, позволяющее использовать объекты классов с одинаковым интерфейсом
             * без информации о типе и внутренней структуре объекта. */

        { // Структуры данных

            /* Структура — это объединение нескольких объектов,
             * возможно, различного типа под одним именем, которое является типом структуры.
             * В качестве объектов могут выступать переменные, массивы, указатели и другие структуры. */

            // Структура прописывается до функции main. Также после структуры надо ставить точку с запятой (;).

            // По умолчанию поля структуры являются публичными.

            struct Structure {
                int per;
                string name;
                double fl;
                struct Structure* child;
            };

            /* Чтобы использовать структуру, нужно, назвать объект этой структуры уже внутри программы.
             * После этого вместе с объектом можно будет использовать все элементы из структуры. */
            int main() {
                struct Structure my_str1;
                my_str1.per = 250;
                my_str1.fl = 23.45;

                // Можно с помощью агрегатной инициализации присвоить все переменные разом, записав данные в том порядке, в котором подходящие типы расположены в структуре:
                    struct Structure my_str2 = {300, "NAME_02", 12.35, NULL};
            };

        }

        { // Классы и объекты

            /* Классы подобны структурам, но в то же время их функционал обширнее, чем у структур.
             * Класс - это абстрактный тип данных, сочетающий в себе два функционала:
             * 1) Это структура, в которой можно хранить различные типы данных: массивы, переменные, функции.
             * 2) Возможность пользоваться объектно-ориентированным программированием.

             * Создав класс можно создать его экземпляр — объект.
             * Объект — это функционирующий прототип класса, которому можно задавать поля и вызывать методы.

             * Поля или свойства — это всё, что может хранить информацию, которую вы потом можете заполнять (переменные, массивы и т.д.).
             * Методы — это обычные функции, в функционале которых можно использовать поля.
             * Чтобы обратится к полям и методам класса нужно перед названием имени свойства поставить точку (.). */

            // Классы, как и структуры, прописываются до функции main. Также после каждого класса надо ставить точку с запятой (;).

            // По умолчанию поля класса являются приватными.

            // Объявление классов в С++:
                class cl {
                public:
                /* Список методов, доступных другим функциям и объектам программы,
                 * т.е. доступных вне используемого класса. */
                private:
                /* Список полей и методов для использования внутри класса,
                 * т.е. доступ к ним имеется только внутри данного класса. */
                protected:
                /* Список средств, доступных при наследовании,
                 * т.е. к этим средствам мы имеем доступ в этом классе, а также в классах-наследниках (рассмотрим позже). */
                };

            // Пример класса:
                class Car {
                private:
                    int height;
                    float speed;
                public:
                    void setValues(int height, float speed) {
                        this->height = height;
                        this->speed = speed;
                        /* Указатель this – это указатель, который хранит адрес конкретного объекта класса.
                         * Он присутствует в виде скрытого первого параметра в каждом методе класса (кроме статических методов).
                         * Типом этого указателя является имя класса. В методах класса, при необходимости, можно использовать this явно.
                         * Однако явно объявлять, инициализировать или изменять этот указатель, нет возможности. */
                    }
                    void print() {
                        cout << "Height: " << this->height << " / " << "Speed: " << this->speed << endl;
                    }
                    void change(int height, float speed);
                };

                // Определение методов вне класса
                    void Car::change(int height, float speed) {
                        this->height += height;
                        this->speed += speed;
                    }

                int main() {
                    Car toyota;
                    toyota.setValues(2, 200.15);
                    toyota.print(); // Выведется "Height: 2 / Speed: 200.15".

                    Car mitsubishi;
                    mitsubishi.setValues(1, 210.001);
                    mitsubishi.print(); // Выведется "Height: 1 / Speed: 210.001".

                    // Можно создавать массивы и векторы объектов:
                        Car cars[3] {
                            Car(2, 120);
                            Car(3, 110.01);
                            Car(2, 11.11);
                        };
                        vector<Car> cars;
                }

        }

        { // Конструкторы и деструкторы

            /* Конструктор - это особый метод класса, который выполняется автоматически в момент создания объекта класса.
             * То есть, если мы пропишем в нем, какими значениями надо инициализировать поля во время объявления объекта класса,
             * он сработает без “особого приглашения”. Его не надо специально вызывать, как обычный метод класса. */

            /* Деструктор - так же особый метод класса, который срабатывает во время уничтожения объектов класса.
             * Чаще всего его роль заключается в том, чтобы освободить динамическую память, которую выделял конструктор для объекта.
             * Имя его, как и у конструктора, должно соответствовать имени класса. Только перед именем надо добавить символ "~". */

            // Пример:
                class Car {
                private:
                    int height = 0;
                    float speed = 0;
                    int size = 0;
                    int* numbers;
                public:
                    Car() { for(int i = 0; i < size; i++) numbers[i] = i; } // Конструктор по умолчанию

                    /* Конструктор по умолчанию – это конструктор класса, который объявляется без параметров.
                     * Если класс не содержит явным образом определенный конструктор,
                     * тогда при создании объекта автоматически вызывается конструктор по умолчанию. */

                    Car(int height, float speed, int size) {
                        this->height = height;
                        this->speed = speed;
                        this->size = size;
                        this->numbers = new int[size];
                        for(int i = 0; i < size; i++) {
                            numbers[i] = i;
                        }
                    } // Конструктор

                    Car(const Car &a) {
                        this->height = a.height;
                        this->speed = a.speed;
                        this->size = a.size;

                        this->numbers = new int[a.size];
                        for(int i = 0; i < a.size; i++) {
                            this->numbers[i] = a.numbers[i];
                        }
                    } // Конструктор копирования

                    /* Конструктор копирования нужен нам для того,
                     * чтобы создавать «реальные» копии объектов класса, а не побитовую копию объекта. */

                    Car(Car &&a) {
                        this->height = std::move(a.height);
                        this->speed = std::move(a.speed);
                        this->size = std::move(a.size);

                        this->numbers = new int[a.size];
                        for(int i = 0; i < a.size; i++) {
                            this->numbers[i] = a.numbers[i];
                        }
                        delete[] a.numbers;
                    } // Конструктор перемещения

                    /* Конструктор перемещения позволяет переместить объект
                     * вместо его копирования для увеличения производительности. */

                    // Можно сократить определения конструкторов, вызвав из одного конструктора другой:
                        Car(int height): Car(height, 20.1, 12) { cout << "Hi" << endl;} // Вызвали первый конструктор не по умолчанию, а потом вывели "Hi"
                        Car(): Car(12) {} // Вызвали прошлый конструктор (в данном случае не сможем так сделать, т.к. мы уже объявляли конструктор по умолчанию)
                        // Такие конструкторы называются делегирующими.

                    void setValues(int height, float speed) {
                        this->height = height;
                        this->speed = speed;
                    }

                    void print() {
                        cout << "Height: " << this->height << " / " << "Speed: " << this->speed << endl;
                    }

                    ~Car() {
                        delete[] numbers;
                        cout << "Work ended" << endl;
                    } // Деструктор (обычно определяется после определения всех остальных методов класса)

                    // В конструкторах и деструкторах можно использовать другие методы класса, не являющиеся конструкторами/деструкторами:
                        Car() {
                            printhello();
                        }
                        ~Car() {
                            printhello();
                        }
                        void printhello {
                            cout << "hello" << endl;
                        };

                    // К конструкторам и деструкторам можно применить спецификатор default:
                        Car() = default;
                        Car(int height, float speed) = default;
                        ~Car() = default;
                        // Его использование указывает компилятору самостоятельно генерировать cоответствующую функцию класса, если таковая не объявлена в классе.

                        /* Ключевое слово default может применяться только к специальным функциям класса,
                         * которые при объявлении класса генерируются компилятором автоматически. К таким функциям относятся:

                             * Конструктор по умолчанию (default constructor);
                             * Конструктор копирования (copy constructor);
                             * Конструктор перемещения (move constructor);
                             * Оператор присваивания копированием (copy assignment operator);
                             * Оператор присваивания перемещением (move assignment operator);
                             * Деструктор (destructor). */
                };

                int main() {
                    Car toyota(2, 200.15, {1, 2, 3}, 3); // Используем новый, описанный нами конструктор. Выведется "Height: 2 / Speed: 200.15".

                    Car mitsubishi; // Используем конструктор по умолчанию
                    mitsubishi.setValues(1, 210.001);
                    mitsubishi.print(); // Выведется "Height: 1 / Speed: 210.001".

                    /* Деструкторы срабатывают после того, как мы завершили работу с классом.
                     * В данном случае "Work ended" выведется 2 раза подряд в конце. */
                }

        }

        { // Дружественные функции

            // Дружественные функции - это функции, которые не являются членами класса,
            // однако имеют доступ к его закрытым членам - переменным и функциям, которые имеют спецификатор private.

            // Для определения дружественных функций используется ключевое слово friend.

                class Person {
                private:
                    int height_in_m;
                    int weight_in_kg;
                public:
                    friend double body_mass_index(const Person&);
                };

                double body_mass_index(const Person& person) {
                    return person.weight_in_kg / pow(person.height_in_m, 2);
                }

            // Определение дружественных функций в классе

                // Дружественные функции могут определяться в другом классе:
                    class Car;
                    class Man {
                    public:
                        Man();
                        void drive(Car&);
                        void setPrice(Car&, int);
                    private:
                        std::string name;
                    };
                    class Car {
                        friend void Man::drive(Car&);
                        friend void Man::setPrice(Car&, int price);
                    public:
                        Car();
                        std::string getName() { return name; }
                        int getPrice() { return price; }
                    private:
                        std::string name;
                        int price;
                    };
                    void Man::drive(Car &a) {
                        std::cout << name << " drives " << a.name << std::endl;
                    }
                    void Man::setPrice(Car &a, int price) {
                        if(price > 0)
                            a.price = price;
                    }

            // Дружественные классы

                /* В случае выше класс Man использует только две функции из класса Car.
                 * Но допустим, что впоследствии возникла необходимость добавить в класс Car
                 * еще ряд дружественных функций, которые будут определены в классе Man,
                 * либо мы можем предполагать, что класс Man будет активно использовать объекты Car.
                 * И в этом случае целесообразно определять не отдельные дружественные функции,
                 * а определить дружественным весь класс Man: */

                    class Man;
                    class Car {
                        friend class Man;
                        ...
                    };
                    /* То есть тем самым мы опять же говорим, что класс Man - это друг класса Car,
                     * поэтому объекты Man могут обращаться к приватным переменным класса Car.
                     * После этого в классе Man можно обращаться к закрытым членам класса Car из любых функций. */

        }

        { // Static в классах

            // Статические поля класса:

                // Статические поля нельзя инициализировать в теле класса, а также в методах.
                // Статические поля должны инициализироваться аналогично глобальным переменным в области видимости файла:

                    class X {
                        static int n;
                        static char ClassName[30];
                    public:
                        static int getN() { return n; }
                        static char* getClass() { return ClassName; }
                        X() { n++; } // конструктор
                    };
                    int X::n = 0;
                    char X::ClassName[] = "My Class";
                    int main() {
                        X a, b, c; // описываем 3 объекта класса X
                        cout << X::getN() << " objects of Class \"" << X::getClass() << "\""  << endl;
                        cin.get();
                        return 0;
                    } // Выведется "3 objects of Class "My Class""

                class A {
                public:
                    A() { std::cout << "Constructor A" << std::endl; }
                    ~A() { std::cout << "Destructor A" << std::endl; }
                };
                class B {
                public:
                    B() { std::cout << "Constructor B" << std::endl; }
                    ~B() { std::cout << "Destructor B" << std::endl; }
                private:
                    static A a; // строка 15 (объявление)
                };
                int main() {
                    B b;
                    return 0;
                } // Выведется "Constructor B" -> "Destructor B"

                /* Причиной такого поведения является то, что статические поля класса не инициализируются с помощью конструктора,
                 * поскольку они не зависят от инициализации объекта. Т.е. в строке 15 мы только объявляем объект, а не определяем его,
                 * так как определение должно происходить вне класса с помощью оператора разрешения области видимости (::). Давайте определим поля класса B. */

                class A {
                public:
                    A() { std::cout << "Constructor A" << std::endl; }
                    ~A() { std::cout << "Destructor A" << std::endl; }
                };
                class B {
                public:
                    B() { std::cout << "Constructor B" << std::endl; }
                    ~B() { std::cout << "Destructor B" << std::endl; }
                private:
                    static A a; // строка 15 (объявление)
                };
                A B::a; // строка 18 (определение)
                int main() {
                    B b;
                    return 0;
                } // Выведется "Constructor A" -> "Constructor B" -> "Destructor B" -> "Destructor A"

                // Нужно помнить, что поле класса будет один для всех экземпляров класса B,
                // т.е. если мы создали три объекта класса B, то конструктор статического поля класса будет вызван только один раз.

                class A {
                public:
                    A() { std::cout << "Constructor A" << std::endl; }
                    ~A() { std::cout << "Destructor A" << std::endl; }
                };
                class B {
                public:
                    B() { std::cout << "Constructor B" << count++ << std::endl; }
                    ~B() { std::cout << "Destructor B" << --count << std::endl; }
                private:
                    static A a; // объявление
                    static int count; // объявление
                };
                A B::a; // определение
                int B::count = 1; // определение
                int main() {
                    B b1, b2;
                    return 0;
                } // Выведется "Constructor A" -> "Constructor B1" -> "Constructor B2" -> "Destructor B2" -> "Destructor B1" -> "Destructor A"

            // Статические объекты класса:

                /* Статический объект класса имеет такие же свойства, как и обычная статическая переменная, описанная выше,
                 * т.е. хранится в статическом сегменте памяти, создается на старте и уничтожается при завершении программы,
                 * и инициализируется только один раз. Инициализация объекта происходит, как и обычно — через конструктор класса. */

                    class Base {
                    public:
                        Base() {
                            std::cout << "Constructor" << std::endl;
                        }
                        ~Base() {
                            std::cout << "Destructor" << std::endl;
                        }
                    };
                    void foo() {
                        Base obj;
                    }
                    void foo_static() {
                        static Base obj;
                    }
                    int main() {
                        foo();
                        std::cout << "End of main()" << std::endl;
                        return 0;
                    } // Выведется Constructor -> Destructor -> End of main()
                    int main() {
                        foo_static();
                        std::cout << "End of main()" << std::endl;
                        return 0;
                    } // Выведется Constructor -> End of main() -> Destructor
                        /* Создание статического объекта будет происходить только при первом вызове функции foo_static().
                         * Из-за того, что объект статический, деструктор вызывается не при выходе из функции foo_static(),
                         * а только при завершении программы, т.к. статический объект разрушается при завершении программы. */

            // Статические методы класса

                /* Статический метод можно использовать без создания объекта класса.
                 * Доступ к статическим функциям осуществляется с использованием имени класса и оператора разрешения области видимости (::).
                 * При использовании статического метода есть ограничения, такие как:

                     * 1. Внутри метода обращаться можно только к статическим полям данных, другим статическим методам и любым другим функциям извне класса.
                     * 2. Статические методы имеют область видимости класса, в котором они находятся.
                     * 3. Вы не имеете доступа к указателю this класса, потому что мы не создаем никакого объекта для вызова этого метода. */

                class A {
                public:
                    A() { std::cout << "Constructor A" << std::endl; }
                    ~A() { std::cout << "Destructor A" << std::endl; }

                    static void foo() {
                        std::cout << "static foo()" << std::endl;
                    }
                };
                int main() {
                    A::foo(); // строка 14
                    return 0;
                } // Выведется "static foo()"

                    /* Из вывода видно, что никакого создания объекта нет и конструктор/деструктор не вызывается.
                     * Если бы метод foo() был бы нестатическим, то компилятор выдал бы ошибку на выражение в строке 14,
                     * т.к. нужно создать объект для того, чтобы получить доступ к его нестатическим методам. */

        }

        { // Перегрузка операторов

            /* Перегрузка операторов позволяет определить действия, которые будет выполнять оператор.
             * Перегрузка подразумевает создание функции, название которой содержит слово operator и символ перегружаемого оператора.
             * Функция оператора может быть определена как член класса, либо вне класса. */

                class Integer {
                private:
                    int number;
                public:
                    Integer(int i): number(i) {}
                    friend Integer operator+(const Integer&, const Integer&);
                    Integer operator+=(const Integer&);
                };

                Integer operator+(const Integer& a, const Integer& b) {
                    return Integer(a.number + b.number);
                }

                Integer Integer::operator+=(const Integer& a) {
                    return this + a;
                }

            // Аргументы и возвращаемые значения

                /* Как можно было заметить, в примерах используются различные способы передачи аргументов в функции и возвращения значений операторов.
                 * Если аргумент не изменяется оператором, его нужно передавать как ссылку на константу.
                 * Тип возвращаемого значения зависит от сути оператора. Если оператор должен возвращать новое значение,
                 * то необходимо создавать новый объект (как в случае бинарного плюса).
                 * Если вы хотите запретить изменение объекта как l-value, то нужно возвращать его константным.
                 * Для операторов присваивания необходимо возвращать ссылку на измененный элемент.
                 * Также, если вы хотите использовать оператор присваивания в конструкциях вида (x = y).f(),
                 * где функция f() вызывается для переменной x, после присваивания ей y, то не возвращайте ссылку на константу, возвращайте просто ссылку.
                 * Логические операторы должны возвращать в худшем случае int, а в лучшем bool. */

            // Особые операторы

                /* В C++ есть операторы, обладающие специфическим синтаксисом и способом перегрузки. Например оператор индексирования [].
                 * Он всегда определяется как член класса и, так как подразумевается поведение индексируемого объекта как массива, то ему следует возвращать ссылку.

                 * В число «особых» операторов входит также оператор запятая.
                 * Он вызывается для объектов, рядом с которыми поставлена запятая (но он не вызывается в списках аргументов функций).

                 * Оператор разыменовывания указателя обязательно определяется как функция класса, причём на него накладываются некоторые ограничения:
                 * он должен возвращать либо объект (или ссылку), либо указатель, позволяющий обратиться к объекту.

                 * Оператор присваивания обязательно определяется в виде функции класса, потому что он неразрывно связан с объектом, находящимся слева от "=".
                 * Определение оператора присваивания в глобальном виде сделало бы возможным переопределение стандартного поведения оператора "=". */

            // Неперегружаемые операторы

                /* Некоторые операторы в C++ не перегружаются в принципе:
                    * Оператор выбора члена класса ".".
                    * Оператор разыменования указателя на член класса ".*"
                    * В С++ отсутствует оператор возведения в степень (как в Fortran) "**".
                    * Запрещено определять свои операторы (возможны проблемы с определением приоритетов).
                    * Нельзя изменять приоритеты операторов. */

            // Рекомендации к форме определения операторов

                /* Все унарные операторы должны быть членами класса;
                 * "=", "()", "[]", "->", "->*" обязательно должны быть членами класса, не иначе;
                 * "+=", "-=", "*=", "/=", "%=", "^=", "&=", "|=", ">>=", "<<=" должны быть членами класса;
                 * Остальные бинарные операторы не должны быть членами класса. */

        }

        { // Вложенные классы

            /* Класс, объявленный внутри другого класса, называется вложенным. Он является членом объемлющего класса,
             * а его определение может находиться в любой из секций public, private или protected объемлющего класса.

             * Имя вложенного класса известно в области видимости объемлющего класса, но ни в каких других областях.
             * Это означает, что оно не конфликтует с таким же именем, объявленным в объемлющей области видимости. */

            class Image {
            public:
                void GetImageInfo() {
                    for(int i = 0; i < length; i++) {
                        cout << "№" << i << ": " << pixels[i].GetInfo() << endl;
                    }
                }
            private:
                class Pixel {
                public:
                    Pixel(int r, int g, int b) {
                        this->r = r;
                        this->g = g;
                        this->b = b;
                    }
                    string GetInfo() {
                        return "Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
                    }
                private:
                    int r;
                    int g;
                    int b;
                };

                static const int length = 5;

                Pixel pixels[length] {
                    Pixel(0, 4, 64),
                    Pixel(0, 14, 16),
                    Pixel(1, 2, 3),
                    Pixel(244, 255, 233),
                    Pixel(111, 122, 132)
                };
            };

            // Допустим, класс Pixel находится в публичной секции класса Image, тогда можно обращаться к классу Pixel в main через "::".
                class Image {
                public:
                    class Pixel {...};
                };
                int main() {
                    Image::Pixel pixel(1, 5, 10) // Объявили объект класса Pixel вне класса Image
                    cout << pixel.GetInfo() << endl; // Использовали его метод
                }
                /* В теории у нас может существовать ещё один класс с именем Pixel вне класса Image,
                 * но компилятор всегда будет понимать, к какому классу мы обращаемся,
                 * т.к. при объявлении объекта вложенного класса мы приписываем пространство имён объемлющего класса. */

        }
    }

    { // Наследование классов

        // Выше я уже описал, что из себя представляет наследование, как один из принципов ООП.

            // Пример наследования класса:

                class Car {
                protected:
                    int height;
                    float speed;
                public:
                    Car() {
                        cout << "Car constructor called" << endl;
                        this->height = 3;
                        this->speed = 501.12;
                    }
                    Car(int height, float speed) {
                        this->height = height;
                        this->speed = speed;
                    }
                    void setValues(int height, float speed) {
                        this->height = height;
                        this->speed = speed;
                    }
                    void print() {
                        cout << "Height: " << this->height << " / " << "Speed: " << this->speed << endl;
                    }
                    ~Car() {
                        cout << "Car destructor called" << endl;
                    }
                };

                class Motorcycle: public Car {

                    /* Теперь мы имеем доступ ко всем методам в public из класса Car, кроме конструкторов и деструкторов.
                     * Однако они вызываются, когда дочерний класс инициализирует свой объект.
                     * Конструкторы вызываются один за другим иерархически, начиная с базового класса и заканчивая последним производным классом.
                     * Деструкторы вызываются в обратном порядке. */

                public:
                    Motorcycle() {
                        cout << "Motorcycle constructor called" << endl;
                    }
                    Motorcycle(float speed): Car(2, speed) {} // Можно вызвать конструктор базового класса
                    ~Motorcycle() {
                        cout << "Motorcycle destructor called" << endl;
                    }
                    void print() {
                        cout << "Height: " << this->height << " / " << "Speed: " << this->speed << endl;
                    }
                };

                int main() {
                    Motorcycle bmw; // Путь конструктора: Car -> Motorcycle.
                    bmw.setValues(10, 210.2); // Вызвали функцию из суперкласса Car.
                    bmw.print(); // Вызовется функция из класса Motorcycle.
                    // Чтобы вызвать функцию с тем же названием из Car, надо написать:
                    bmw.Car::print();
                    // Путь деструктора: Motorcycle -> Car.

                    // Также мы можем обращаться через указатели суперклассов к классам-наследникам:
                        Motorcycle motorcycle;
                        Car* some_car = &motorcycle;
                }

            // Множественное наследование:

                class Supplies {
                protected:
                    float weight;
                public:
                    void setWeight(float weight) {
                        this->weight = weight;
                    }
                    void print() {
                        cout << "Weight is: " << weight << endl;
                    }
                };
                class Truck: public Car, public Supplies {}; // Порядок вызова конструкторов: Car -> Supplies -> Truck

                int main() {
                    Truck mercedes;
                    mercedes.setWeight(1602.78); // Используем метод из класса Supplies
                    mercedes.setValues(7, 102.2); // Используем метод из класса Car
                } // Порядок вызова деструкторов: Truck -> Supplies -> Car

                /* Множественное наследование требует тщательного проектирования, так как может привести к непредвиденным последствиям.
                 * Большинство таких последствий вызваны неоднозначностью в наследовании.
                 * В данном примере Truck наследует метод print() от обоих родителей и неясно какой метод должен быть вызван.
                 * Чтобы вызвать определённый метод, нужно приписать до объекта название класса, из которого мы берём метод: */
                    ((Car).mercedes).print();
                    ((Supplies).mercedes).print();

                // Ромбовидное наследование

                    /* Ситуация, когда два класса B и C наследуют от A, а класс D наследует от обоих классов B и C.
                     * При этой схеме наследования может возникнуть неоднозначность:
                     * если объект класса D вызывает метод, определенный в классе A (и этот метод не был переопределен в классе D),
                     * а классы B и C по-своему переопределили этот метод, то от какого класса его наследовать: B или C? */

                    class A {};
                    class B: public A {};
                    class C: public A {};
                    class D: public B, public C {};

                    /* C++ по умолчанию не создает ромбовидного наследования: компилятор обрабатывает каждый путь наследования отдельно,
                     * в результате чего объект D будет на самом деле содержать два разных подобъекта A,
                     * и при использовании членов A потребуется указать путь наследования (B::A или C::A). */

    }

    { // Агрегация и композиция

        /* В ООП существует два способа организации взаимодействия между классами: наследование (описано выше) и ассоциация.
         * Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей.
            * В ассоциации выделяют два частных случая: композицию и агрегацию.
            * Разница между композицией и агрегацией заключается в том, что
            * в случае композиции целое явно контролирует время жизни своей составной части (часть не существует без целого),
            * а в случае агрегации целое хоть и содержит свою составную часть, время их жизни не связано. */

            class Cap {...};
            class Human {
            private:
                class Brain {...};
                Brain brain; // Композиция
                Cap cap; // Агрегация
            };

    }

    { // Виртуальные функции

        /* Виртуальная функция — это метод, который предполагается переопределить в производных классах.
         * При ссылке на объект производного класса с помощью указателя или ссылки на базовый класс
         * можно вызвать виртуальную функцию для этого объекта и выполнить версию функции производного класса. */

            class Gun {
            public:
                virtual void shoot() {
                    cout << "pew" << endl;
                }
            };

            class Pistol: public Gun {
            public:
                void shoot() {
                    cout << "BANG" << endl;
                }
            };

            // Мы также можем использовать спецификатор override для назначения функций-членов, которые переопределяют виртуальную функцию в базовом классе.
            // Этот спецификатор не является обязательным и используется для того, чтобы компилятор генерировал ошибки вместо автоматического создания новых методов.

                class BaseClass {
                    virtual void funcA();
                    virtual void funcB() const;
                    virtual void funcC(int = 0);
                    void funcD();
                };

                class DerivedClass: public BaseClass {
                    virtual void funcA() override; // Скомпилируется
                    virtual void funcB() override; // Не скомпилируется, т.к. funcB() в классе BaseClass является const (не происходит перегрузки).
                    virtual void funcC( double = 0.0 ) override; // Не скомпилируется, т.к. передаваемый тип в классе BaseClass является int.
                    void funcD() override; // Не скомпилируется, т.к. метод funcD() в классе BaseClass не является виртуальным.
                };

            // При использовании указателей родительских классов на производные классы будут вызываться перегруженные (!!!) методы из производных классов.

                int main() {
                    Pistol pistol;
                    Gun* some_gun = &pistol;
                    some_gun->shoot(); // Выведется "BANG"
                }

            // Если же мы уберём ключевое слово virtual в суперклассе, будет вызываться уже метод из суперкласса.

                class Gun {
                public:
                    void shoot() {
                        cout << "pew" << endl;
                    }
                };

                class Pistol: public Gun {
                public:
                    void shoot() {
                        cout << "BANG" << endl;
                    }
                };

                int main() {
                    Pistol pistol;
                    Gun* some_gun = &pistol;
                    some_gun->shoot(); // Выведется "pew"
                }

            // Виртуальные функции пригождаются, когда мы используем указатель как аргумент функции, например:

                class Gun {
                public:
                    virtual void shoot() {
                        cout << "pew" << endl;
                    }
                };

                class Pistol: public Gun {
                public:
                    void shoot() {
                        cout << "BANG" << endl;
                    }
                };

                class Player {
                public:
                    void shoot(Gun* gun) {
                        gun->shoot();
                    }
                };

                int main() {
                    Player player;
                    Gun gun;
                    player.shoot(&gun) // Выведется "pew"
                    Pistol pistol;
                    player.shoot(&pistol); // Выведется "BANG"
                }
        // Чисто виртуальные функции

            /* Базовый класс может и не предоставлять реализации виртуального метода, а только декларировать его существование.
             * Такие методы без реализации называются "чисто виртуальными" (pure virtual) или абстрактными.
             * Чисто виртуальная функция действует как просто заполнитель, который должен быть переопределен производными классами.
             * Класс, содержащий хотя бы один такой метод, тоже будет абстрактным.
             * Объект такого класса создать нельзя. Наследники абстрактного класса должны предоставить реализацию для всех его абстрактных методов,
             * иначе они, в свою очередь, будут абстрактными классами. */

            class Weapon {
            public:
                virtual void shoot() = 0; // "= 0" сообщает компилятору, что данная функция чисто виртуальная.
            };

            class Gun: public Weapon {
            public:
                void shoot() override {
                    cout << "pew" << endl;
                }
            };

            class Pistol: public Gun {
            public:
                void shoot() override {
                    cout << "BANG" << endl;
                }
            };

            class Taser: public Weapon {
                void shoot() override {
                    cout << "bzzz" << endl;
                }
            };

            class Player {
            public:
                void shoot(Weapon* weapon) {
                    weapon->shoot();
                }
            };

            // Интерфейс

                /* Интерфейсом называется абстрактный класс, не имеющий данных и состоящий только из чисто виртуальных функций.
                 * Такое решение позволяет полностью отделить реализацию от интерфейса (клиент использует интерфейсный класс),
                 * в другом месте создается производный класс, в котором переопределяются чисто виртуальные функции и определяется функция-фабрика. */

                class IFBicycle {
                public:
                    void virtual TwistWheel() = 0;
                    void virtual Ride() = 0;
                };

                class SimpleBicycle: IFBicycle { // Говорим: не наследуемся от интерфейса, а реализовываем интерфейс
                public:
                    void TwistWheel() override {
                        cout << "SimpleBicycle TwistWheel()" << endl;
                    }
                    void Ride() override {
                        cout << "SimpleBicycle Ride()" << endl;
                    }
                };

                class SportBicycle: IFBicycle {
                public:
                    void TwistWheel() override {
                        cout << "SportBicycle TwistWheel()" << endl;
                    }
                    void Ride() override {
                        cout << "SportBicycle Ride()" << endl;
                    }
                };

                class Human {
                public:
                    void RideOn(IFBicycle& bicycle) {
                        bicycle.TwistWheel();
                        bicycle.Ride();
                    }
                };

                int main() {
                    Human human;

                    SimpleBicycle simplebicycle;
                    SportBicycle sportbicycle;

                    human.RideOn(simplebicycle); // Вызовется "SimpleBicycle TwistWheel()" -> "SimpleBicycle Ride()"
                    human.RideOn(sportbicycle); // Вызовется "SportBicycle TwistWheel()" -> "SportBicycle Ride()"
                }

        // Виртуальный деструктор

            // Основное правило: если у вас в классе присутствует хотя бы одна виртуальная функция, деструктор также следует сделать виртуальным.
            // При этом не следует забывать, что деструктор по умолчанию виртуальным не будет, поэтому следует объявить его явно.

                class A {
                public:
                    A() { cout << "A()" << endl; }
                    ~A() { cout << "~A()" << endl; }
                };

                class B: public A {
                public:
                    B() { cout << "B()" << endl; }
                    ~B() { cout << "~B()" << endl; }
                };

                int main() {
                    B b;
                    return 0;
                } // Выведется "A()" -> "B()" -> "~B()" -> "~A()"

                // Теперь попробуем создать тот же объект в динамической памяти, используя при этом указатель на объект базового класса.

                int main() {
                    A* pA = new B;
                    delete pA;
                    return 0;
                } // Выведется "A()" -> "B()" -> "~A()" и происходит утечка памяти, т.к. ~B() не вызывается.

                /* Происходит это потому, что удаление производится через указатель на базовый класс и для вызова деструктора компилятор использует раннее связывание.
                 * Деструктор базового класса не может вызвать деструктор производного, потому что он о нем ничего не знает.
                 * В итоге часть памяти, выделенная под производный класс, безвозвратно теряется. */

                // Чтобы этого избежать, деструктор в базовом классе должен быть объявлен как виртуальный:
                    class A {
                    public:
                        A() { cout << "A()" << endl; }
                        virtual ~A() { cout << "~A()" << endl; }
                    };

                    class B : public A {
                    public:
                        B() { cout << "B()" << endl; }
                        ~B() { cout << "~B()" << endl; }
                    };

                    int main() {
                        A* pA = new B;
                        delete pA;
                        return 0;
                    } // Выведется "A()" -> "B()" -> "~B()" -> "~A()"

                    /* Происходит так потому, что отныне для вызова деструктора используется позднее связывание,
                     * то есть при разрушении объекта берется указатель на класс,
                     * затем из таблицы виртуальных функций определяется адрес нужного нам деструктора, а это деструктор производного класса,
                     * который после своей работы, как и полагается, вызывает деструктор базового. */

            // Виртуальные функции в деструкторах

                // При вызове виртуальных методов из деструктора компилятор использует не позднее, а раннее связывание.

                class Cat {
                public:
                    virtual ~Cat() { sayGoodbye(); }
                    virtual void sayGoodbye() const { cout << "Meow-meow!" << endl; }
                };

                class Ben: public Cat {
                public:
                    void sayGoodbye() const override { cout << "Bye-bye! :)" << endl; }
                };

                int main() {
                    Cat* cats[] = { new Cat, new Ben };
                    delete cats[0]; delete cats[1];
                    return 0;
                } // Выведется "Meow-meow!" -> "Meow-meow!"

                /* Когда мы создаем объект типа Ben, порядок вызовов конструкторов/деструкторов будет таким:
                 * Cat() -> Ben() -> ~Ben() -> ~Cat()

                 * Когда же мы хотим внутри деструктора ~Cat() совершить виртуальный вызов метода sayGoodbye(),
                 * то мы фактически пытаемся обратиться к той части объекта, которая уже была разрушена. */

            // Чисто виртуальный деструктор

                // Чисто виртуальный деструктор используется для того, чтобы сделать класс абстрактным, не создавая чисто виртуальных функций,
                // а также гарантировать корректное удаление экземпляров производных классов через указатель или ссылку на базовый.

                class Sample {
                public:
                    virtual ~Sample() = 0;
                };
                class DSample: public Sample {};

        // Виртуальное наследование

            /* Виртуальное наследование — один из вариантов наследования,
             * который нужен для решения некоторых проблем, порождаемых наличием возможности множественного наследования (особенно "ромбовидного наследования"),
             * путём разрешения неоднозначности того, методы которого из суперклассов (непосредственных классов-предков) необходимо использовать.
             * Оно применяется в тех случаях, когда множественное наследование вместо предполагаемой полной композиции свойств классов-предков
             * приводит к ограничению доступных наследуемых свойств вследствие неоднозначности.
             * Базовый класс, наследуемый множественно, определяется виртуальным с помощью ключевого слова virtual. */

            class Animal {
            public:
                void eat() {...};
                ...
            };

            class Mammal : public Animal {
            public:
                void getHairColor() {...};
                ...
            };

            class WingedAnimal : public Animal {
            public:
                void flap() {...};
                ...
            };

            // Летучая мышь - это летающее млекопитающее
            class Bat : public Mammal, public WingedAnimal {}; // <--- обратите внимание, что метод eat() не переопределен в Bat
            Bat bat;

            /* Для вышеприведенного кода вызов bat.eat() является неоднозначным.
             * Он может относиться как к Bat::WingedAnimal::Animal::eat(), так и к Bat::Mammal::Animal::eat().
             * У каждого промежуточного наследника (WingedAnimal, Mammal) метод eat() может быть переопределен (это не меняет сущность проблемы с точки зрения языка). */

            class Animal
            {
            public:
                virtual void eat() {...}; // Метод определяется для данного класса
                ...
            };

            // Two classes virtually inheriting Animal:
            class Mammal : public virtual Animal { // <--- обратите внимание на ключевое слово virtual
            public:
                void getHairColor() {...};
                ...
            };

            class WingedAnimal : public virtual Animal { // <--- обратите внимание на ключевое слово virtual
            public:
                void flap() {...};
                ...
            };

            // Летучая мышь всё ещё летающее млекопитающее
            class Bat : public Mammal, public WingedAnimal {};

            /* Теперь часть Animal объекта класса Bat::WingedAnimal та же самая, что и часть Animal, которая используется в Bat::Mammal,
             * и можно сказать, что Bat имеет в своем представлении только одну часть Animal и вызов Bat::eat() становится однозначным.

             * Виртуальное наследование реализуется через добавление указателей в классы Mammal и WingedAnimal.
             * Таким образом, Bat представляется, как (ptr, Mammal, ptr, WingedAnimal, Bat, Animal).
             * *ptr содержит информацию о смещении в памяти между началом Mammal/WingedAnimal и его Animal.
             * За счёт этого обеспечивается не только исключение дублирования общей Animal части для Mammal и WingedAnimal,
             * но и простой механизм преобразования указателя (ссылки) на объект класса наследника в указатель (ссылку) на объект любого базового класса. */
    }

    return 0; // Показывает, что функция main завершилась успешно. Во многих компиляторах производится автоматически.
}
