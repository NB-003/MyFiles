// Язык C++ основан на языке Си. Всё, что описано в файле "Си для чайников", подойдёт и для языка C++.

#include <iostream> /* Одна из ключевых библиотек, которую нужно вызвать
для использования определённых функций (напр., cin или cout). Аналог <stdio.h> из Си. */
#include <string> // Эта библиотека позволяет нам проводить различные операции со строками.
#include <vector> // Эта библиотека позволяет нам работать с векторами (вектор - это динамический массив).

using namespace std; /* Ключевое слово namespace используется
для объявления области действия, которая содержит набор связанных объектов.
Например, using namespace std сообщает компилятору, что мы хотим использовать всё, что находится в пространстве имен std.
Можно написать перед функцией main или внутри неё, используя std перед каждой функцией из области действия (напр., std::cout) */

int main() { // С функции main начинается каждая программа в языке C++

    cout << "Hello, World!" << endl; // Вывод строки.

    { // Переменные

        /* Объявление переменной:
         * Тип переменной, потом название переменной, затем можно либо
         * присвоить этой переменной значение (=), либо
         * закрыть строку (;), тем самым просто запомнив эту переменную.
         * После этого с этой переменной можно производить любые операции. */
        int num_first = 1;

        // Типы данных
        // int - целочисленный тип данных
        num_first = 6;
        // short - также целочисленный тип данных, но с меньшим диапазоном (от -32768 до 32768), зато использует в 2 раза меньше памяти
        short sh = 32000;
        // Также есть long (и ещё long long), который имеет в разы больший диапазон, нежели int, но и памяти также использует в 2 раза больше
        long ln = 126379781;

        /* К переменным с целочисленным типом можно приписывать unsigned, что лишает переменную всех отрицательных значений,
         * но использует столько же памяти (т.е. диапазон в положительную сторону увеличивается). */

        // float - вещественный тип данных (число с плавающей точкой), точность - 7 разрядов
        float num_float = 1.012393f; // В float можно на конце писать f, но необязательно
        // double - также вещественный тип данных, но с большей точностью (15 разрядов)
        // Также есть long double, имеющий точность 21 разряд

        // char - символьный тип данных (можно поместить только один символ)
        char c = 'c'; // При переменной типа char символ нужно помещать именно в одинарные кавычки (')

        // bool - булевый тип данных, имеющий только 2 значения - true и false
        bool fls = false;
        // Вместо true и false можно использовать 1 и 0 соответственно

        // Можно объявлять сразу несколько переменных:
        int x, y, z;
        int p = 10, q = 9, r, t;

        // Можно задавать константы (постоянные):
        const int c = 1;
        // Но! Потом будет нельзя присваивать к этой переменной другие значения! (На то она и константа)
        c = 3 // Нельзя!

        // С типами int и float (вещественный тип данных) можно производить различные математические операции:
        r = p + q;

        // Производить можно + (сложение), - (вычитание), * (умножение), / (деление), % (остаток от деления).

        /* Производя вычисления над одной и той же переменной, можно сокращать синтаксис:
        * x = x + 5 это то же самое, что и x += 5.
        * ++ - прибавление к переменной единицы (+1), инкремент (аналогично, -- - декремент, уменьшение на 1).
        * Инкременты и декременты можно использовать как перед переменной, так и после неё, но есть отличия. */

        int x = 5;
        int y = ++x; // x = 6 и 6 присваивается переменной y

        int x = 5;
        int y = x++; // x = 6, но переменной y присваивается 5
    }

    { // Ввод и вывод символов

        // cout - функция вывода
            cout << "there!" << endl; // Выведется there!
            // endl - конец строки. Равносильно "\n", "\0" и т.д..

            // Можно вывести несколько строк:
                cout << "Hello" << " " << "there!"<< endl; // Выведется "Hello there!"

        // cin - функция ввода
            int lol1, lol2;
            cout << "Enter lol1:" << endl;
            cin >> lol1;
            cout << "Enter lol2:" << endl;
            cin >> lol2;
    }

    { // Условные операторы

        // Как используется условный оператор if:
            int x = 5;
            if(x == 5) { /* Идёт проверка условия.
                         * Если условие истинно, выполнится тело условия.
                         * Если условие ложно, то тело условия не выполнится. */
                cout << "x равно 5" << endl;
            } else if(x > 5) { // Дополнительная проверка, которая выполняется в том случае, если if не выполнилось.
                cout << "x больше, чем 5" << endl;
            } else { // else выполняется только в том случае, если if и все else if не выполнились.
                cout << "x меньше, чем 5" << endl;
            } // else и else if пишутся после if (если else или else if используются). else if всегда помещается между if и else.
            // Если в теле условия используется всего одна строка, фигурные скобки ({}) можно не использовать.
            // Также можно использовать новое условие в теле другого условия:
            if(x >= 5) {
                if (x == 5)
                    cout << "Yes" << endl;
                else
                    cout << "No" << endl;
            }

        // Все операторы сравнения: == (равно), != (не равно), < (меньше), > (больше), <= (меньше или равно), >= (больше или равно)
        // Логические операторы: || (логическое ИЛИ), && (логическое И), ! (логическое НЕ)

        // Условные операторы также позволяют работать с булевыми значениями:
            bool istrue = true;
            bool isfalse = false;
            if (istrue && !isfalse) cout << "Hi!" << endl;
                /* Тело будет выполняться, если булево значение истинно (при ! - ложно),
                 * причём достаточно просто написать название булевой переменной. */
            else cout << "Bye!" << endl;

        // Тернарный оператор (укороченая запись типа if..else..)
            int num = 1 == 1 ? 10 : 20; /* Если условие (в данном случае 1 == 1) истинно,
            то переменной num присваивается значение 10, иначе присваивается значение 20 */

        // Оператор принятия решений switch-case
            int x = 6;
            switch(x) { // В switch-case можно проверять только на точное совпадение значений.
                case 5:
                    cout << "5" << endl;
                    break; // Проверяет от case до break, т.е. следующие case уже не проверяются.
                case 9:
                    cout << "9" << endl;
                    break;
                case 2:
                    cout << "2" << endl;
                    break;
                default: // default сработает в том случае, если каждый из case не был выполнен.
                    cout << "ok" << endl;
                    break;
                    // switch-case намного короче и удобнее для проверки определённой переменной на соответствие различным значениям.
            }
    }

    { // Массивы

        // Объявление массива:
        /* Сначала указываем тип всех элементов массива,
        * затем называем массив,
        * после этого в квадратных скобках пишем количество элементов в массиве.
        * Также можно сразу присвоить каждому элементу значение, это делается за счёт фигурных скобок.
        * Если сразу присваиваем значения элементам, необязательно писать количество элементов в квадратных скобках. */
            int arr[] = {1, 3, 5, 7, 9};

        // Отсчёт по элементам в массиве начинается с 0, т.е. 1 элемент имеет индекс [0] и т.д.
            cout << arr[2] << endl; // Выведет 3 элемент, т.е. 2

        // Можно и переприсвоить значение элементу массива:
            arr[2] = 2;

        // Двумерный массив
            int array[3][4] = {
                    {4, 5, 6, 7},
                    {7, 8, 9, 10},
                    {4, 6, 8, 10}
            }; /* Двумерный массив - своеобразная матрица из различных элементов, выстроенная в столбцы и ряды.
                * В двумерных массивах обязательно надо обозначать размерность.
                * Первая скобка отвечает за то, сколько маленьких массивов будет внутри большого (двумерного) массива.
                * Вторая скобка отвечает за то, сколько элементов будет в маленьких массивах.
                * Работа с двумерными массивами почти не отличается от работы с обычными, надо просто писать два аргумента. */
            // Также существуют трёхмерные и четырёхмерные массивы.
    }

    { // Циклы

        // Цикл с параметром for:
            for(int i = 0; i < 10; i++) { /* В цикле for используется 3 операции внутри скобок:
                                           * Первая операция отвечает за инициализацию
                                           * (обозначаем переменную-параметр, который будет использоваться в цикле)
                                           * Эта переменная будет использована только в цикле и не будет запомнена в самой программе.
                                           * Вторая операция отвечает за условие
                                           * (цикл будет работать, пока условие выполняется (т.е. является истинным)).
                                           * Третья операция отвечает за модификацию
                                           * (как будет изменяться значение переменной-параметра). */
                cout << i << endl;
            } // Этот цикл выведет в консоль все числа от 0 до 9.

        // Цикл с условием while:
            bool t = true;
            int x;
            while(t) { // В цикле while используется 1 операция внутри скобок - условие.
                cin >> x;
                if(x == 1)
                    t = false;
            } // Этот цикл закончится, если в консоли ввести число 1.

        // Как из цикла while можно сделать цикл for:
            int i = 0;
            while(i < 10) {
                cout << i << endl;
                i++;
            } // Этот цикл аналогичен тому, что я написал выше, где описывал цикл с параметром.

        // Цикл с условием do-while:
        /* Отличие цикла do-while от цикла while в том, что
         * цикл do-while сначала выполняет тело цикла, а затем проверяет условие, а не наоборот, как в случае с while.
         */
            bool f = false;
            do {
                cout << "Hi" << endl;
            } while(f);// Этот цикл выполнится 1 раз, т.к. условие не выполняется.

        // Операторы внутри циклов:
            for(int x = 0; x < 10; x++) {
                if(x == 5)
                    break; // Оператор break незамедлительно завершает цикл, игнорируя последующие строки кода в теле цикла.
                if(x % 2 == 0)
                    continue; /* Оператор continue пропускает одну итерацию в цикле,
                               * т.е. игнорирует последующие строки кода в теле цикла, перемещаясь к следующему оператору.
                               * Например, в данном случае цикл будет пропускать все чётные числа.
                               */
                cout << x << endl;
            } // На экран выведутся числа 1 и 3.

        // С массивами также можно производить различные операции в циклах:
            int array[] = {3, 0, 9, 10, -90, -24};
            for(int i = 0; i < 6; i++)
                cout << array[i] << endl; // Этот цикл выведет в консоль все элементы массива.

            int min = array[0];
            for(int i = 0; i < 6; i++) {
                if(array[i] < min)
                    min = array[i]; // Цикл по нахождению минимального по значению элемента в массиве.
            }
    }

    { // Строки (работает при подключении библиотеки <string>)

        // Как работают строки на Си:
            char word[] = {'S','o','m','e'}; // То же самое, что и:
            char words[] = "Some"; // В строках используем обязательно двойные кавычки (").
            // Проще говоря, это массив символов.

        // На C++ появилась возможность использовать строки как отдельный тип данных:
            string some = "Some";
            cout << some << endl; // Выведется "Some".

        // Строки можно конкатенировать:
            string one = "One";
            string two = "Two";
            cout << one + two << endl; // Выведется "OneTwo".
    }

    { // Векторы (работает при подключении библиотеки <vector>)

        /* Векторы - это динамические массивы,
         * т.е. если массив мы можем заполнить элементами только до того количества элементов, которое мы изначально указали,
         * то вектор мы можем растянуть,
         * т.е. по ходу можем добавить дополнительные элементы, выходящие за предел ранее указанного количества. */

        vector <int> vector1(10);

        // Можно поместить элемент или массив в вектор, используя функцию insert():
            vector1.insert(vector1.begin(), 10); // Добавляем в начало вектора vector1 элемент со значением 10

            int arr[] = {1, 2, 3, 4};
            vector1.insert(vector1.begin(), arr, arr + 3); /* Добавляем в начало вектора vector1
                                                                            элементы с первого по третий массива arr. */

            /* Функцию insert() вектора можно использовать по-разному для разных целей.
             * Ниже указаны три разных синтаксиса этой функции. */ {

                iterator insert(const_iterator position, const value_type &value);
                /* Вышеупомянутая функция insert() используется для вставки значения аргумента value перед позицией элемента вектора,
                 * упомянутого аргументом position. Он возвращает итератор, указывающий на вновь вставленный элемент вектора. */

                iterator insert(iterator position, size_type n, const value_type &value);
                /* Вышеупомянутая функция insert() будет работать аналогично функции insert(), упомянутой ранее,
                 * но она будет вставлять одно и то же значение несколько раз в векторный объект. */

                iterator insert(const_iterator position, InputIterator first, InputIterator last);
                /* Вышеупомянутая функция insert() будет вставлять диапазон элементов перед позицией элемента вектора,
                 * упомянутого аргументом позиции. Он возвращает итератор,
                 * который указывает на вновь вставленные элементы вектора, как и две предыдущие функции insert(). */
            }

        // Также можно вставлять элемент в конец вектора, используя функцию push_back():
            vector1.push_back(45);

        // Можно вывести элемент вектора:
            cout << vector1.at(1) << endl; // На месте аргумента функции at() пишем индекс элемента вектора, который мы хотим вывести.
            cout << vector1.front() << endl; // Выведется первый элемент вектора.
            cout << vector1.back() << endl; // Выведется последний элемент вектора.

    }

    { // Функции

        // Функции - это подпрограммы, в которые можно вносить повторяющийся код, а после этого вызывать их, выполняя код внутри функции.
        // Чтобы создать функцию, необходимо прописать её до функции main().
            // Сначала необходимо прописать тип данных, который будет возвращён самой функцией.
                // Чтобы функция что-либо возвращала, надо указать определённый тип данных, который эта функция будет возвращать:
                    double mult(double a, double b) {
                        double res = a * b;
                        return res;
                    }
                    // Внутри main() это будет задействовано следующим образом:
                        int main() {
                            double x = 5.5, y = 9.2;
                            cout << mult(x, y) << endl;
                            return 0; /* На ключевом слове return и числе 0 заканчивается любая программа в языке C,
                                       * в которой использовалось int перед main.
                                       * return 0 необязательно использовать в конце функции main в C99 или C11, но обязательно в C89.
                                       * Также вместо int main можно использовать void main. */
                        };

                // Если функция ничего не возвращает, то тип данных указывается void.
                    void info() {
                        cout << "Привет" << endl;
                    }

            // Внутри функции можно использовать свои переменные, их просто нужно задать в скобках:
                void sum(int a, int b) {
                    int res = a + b;
                    cout << res << endl;
                } // Заданные в функции переменные не будут распространяться на всю остальную программу.

                // Внутри кода переменные используются следующим образом:
                    int main() {
                        sum(20, 50);
                        int x = 9, y = 2;
                        sum(x, y);
                    } // Т.е. вместо a и b можно вставить любое число или переменную того же типа.

                // Также внутри функции можно передать и массив:
                    void hello(int arr[]) {
                        for(int i = 0; i < 10; i++) {
                            cout << arr[i] << endl;
                        };
                    }

                // И также строки:
                    void print(string word) {
                        cout << word << endl;
                    }

        // Чтобы вызвать функцию, надо внутри функции main() обратиться к функции по имени:
            int main() {
                info();
            }

        // Чтобы функция могла принимать аргументы другого количества и других типов данных, используется перегрузка функций:
        void print(string word) {
            cout << word << endl;
        }
        void print(float term1, float term2) {
            cout << term1 + term2 << endl;
        }
        int main() {
            print("Hello World!");
            print(1.25, 1.75);
        }

        // Функцию можно прописать и после функции main, но для этого нужно обратиться к ней до функции main():
            void info(void); // Если обращаемся к функции до main и внутри неё нет параметров, надо указать в скобках void.
            int main() {
                info();
                return 0;
            }
            void info() {
                cout << "Привет" << endl;
            }

        // Также функции можно прописывать при помощи заголовочных файлов:
            /* Необходимо создать заголовочный файл с расширением .h (как у библиотек),
             * затем нужно прописать в этом файле функцию, которую мы хотим использовать,
             * после этого этот код можно использовать и в основной программе,
             * нужно просто до функции main написать #include "[название_файла].h" (без скобок и в двойных кавычках),
             * а затем вызвать функцию по её названию уже внутри main. */
                #include "functions.h"
                int main() {
                    info();
                }

        // Можно совершать проверки на исключения в функциях с помощью блока try-catch и оператора throw (необязательно):
            float del(float a, float b) {
                int res;
                try {
                    if(b != 0)
                        res = a / b;
                    else
                        throw b; // Сгенерировали исключение с помощью throw.
                } catch(float num) {
                    cout << num; // выведется исключение, т.е. значение b, т.е. 0
                }
                return res;
            }
            /* В блок после ключевого слова try помещается код, который потенциально может сгенерировать исключение.
             * Оператор throw генерирует исключение. Через оператор throw можно передать информацию об ошибке.
             * После ключевого слова catch в скобках идет параметр, который передает информацию об исключении.
             * Затем в блоке производится собственно обработка исключения.
             * В качестве аргумента в catch() передаётся тот тип данных, который catch() "ловит" в качестве исключения.
             * Т.е., если ранее throw сгенерировало исключение с типом данных float (как в вышеуказанном примере),
             * то catch() должен принимать исключение с типом float. */
    }

    { // Указатели и ссылки

        // Указатель - это некоторая переменная, которая содержит адрес другого объекта. Указатели сильно оптимизируют код.
            int num = 0;
            int *ptrNum = &num; // Называем указатель (перед ним ставим *) и присваиваем ему адрес переменной, которую мы хотим использовать.
            cout << *ptrNum << endl; // Выведется значение переменной num, т.е. 0.
            cout << ptrNum << endl; // Так мы выведем адрес переменной num. То же самое, что и cout << &num << endl.
            cin >> *ptrNum; // Таким образом мы изменим значение переменной num.

            // Можно ссылаться и на адрес указателя (и т.д.):
                int **ptr_ptrNum = &ptrNum; // То же самое, что и int *ptr_ptrNum = ptrNum.
                cin >> **ptr_ptrNum; // Сначала в указатель ptrNum передастся значение из ptr_ptrNum, а затем из него к переменной num.

            /* В массиве указатель изначально всегда указывает на первый элемент.
             * Т.е. при использовании функции мы передаём не весь массив, а его указатель. */
                int arr1[] = {1, 3, 6, 0};
                int func_using_arr1(int* arr1);

            // Запись типа array[n] всегда эквивалентна записи *(array + n).

        // Ссылка - это особый тип данных, который является скрытой формой указателя и при использовании автоматически разыменовывается.
            int &refNum = num; // То же самое, как если бы мы написали int *ptrNum = &num.
            cout << refNum << endl; // Выведется значение переменной num, т.е. 0.
            cin >> refNum; // Таким образом мы изменим значение переменной num.

            // Нельзя передать в ссылку весь массив, но можно передать в ссылку указатель на массив:
                int arr2[] = {1, 2, 3};
                int &ref = *arr2;

        // По сути в практическом применении между указателями и ссылками особо нет разницы.

        /* Разница между указателями и ссылками:
         * Основное назначение указателей - это организация динамических объектов,
         * например, объекты, которые могут увеличиваться или уменьшаться,
         * Ссылки же предназначены для прямого доступа к тому или иному объекту.
         * Т.е. благодаря ссылке мы имеем прямой доступ к объекту,
         * а указатель как бы копирует объект и уже непосредственно как изменяется сам, так и изменяет объект, на который указывает.

         * Указатель ссылается на участок в памяти, используя адрес.
         * Ссылки же ссылаются на объект по его имени (тоже своего рода адрес). */

    }

    { // Объектно-ориентированное программирование

        /* Объектно-ориентированное программирование (ООП) — это подход,
         * при котором программа рассматривается как набор объектов, взаимодействующих друг с другом.
         * У каждого объекта есть свойства и поведение. ООП ускоряет написание кода и делает его более читаемым.

         * Объектно-ориентированное программирование используется, чтобы:
             * 1) Структурировать информацию и не допускать путаницы;
             * 2) Точно определять взаимодействие одних элементов с другими;
             * 3) Повышать управляемость программы;
             * 4) Быстрее масштабировать код под различные задачи;
             * 5) Внедрять изменения без необходимости переписывать весь код.

         * Принципы ООП:
         * Объектно-ориентированное программирование определяют через три принципа, по которым можно понять основы работы.

             * Инкапсуляция — это свойство, позволяющее объединить в классе и данные,
             * и методы, работающие с ними, и скрыть детали реализации от пользователя.

             * Наследование — это свойство, позволяющее создать новый класс-потомок на основе уже существующего,
             * при этом все характеристики класса родителя присваиваются классу-потомку.

             * Полиморфизм — свойство классов, позволяющее использовать объекты классов с одинаковым интерфейсом
             * без информации о типе и внутренней структуре объекта. */

        { // Структуры данных

            /* Структура — это объединение нескольких объектов,
             * возможно, различного типа под одним именем, которое является типом структуры.
             * В качестве объектов могут выступать переменные, массивы, указатели и другие структуры. */

            // Структура прописывается до функции main. Также после структуры надо ставить точку с запятой (;).

            // По умолчанию поля структуры являются публичными.

            struct Structure {
                int per;
                string name;
                double fl;
                struct Structure* child;
            };

            /* Чтобы использовать структуру, нужно, назвать объект этой структуры уже внутри программы.
             * После этого вместе с объектом можно будет использовать все элементы из структуры. */
            int main() {
                struct Structure my_str1;
                my_str1.per = 250;
                my_str1.fl = 23.45;
                // Можно создавать множество объектов на основе одной структуры:
                struct Structure my_str2 = {300, "NAME_02", 12.35, NULL};
                // Можно присвоить все переменные разом, главное записать всё в том порядке, в котором они расположены в структуре.
            };

        }

        { // Классы и объекты

            /* Классы подобны структурам, но в то же время их функционал обширнее, чем у структур.
             * Класс - это абстрактный тип данных, сочетающий в себе два функционала:
             * 1) Это структура, в которой можно хранить различные типы данных: массивы, переменные, функции.
             * 2) Возможность пользоваться объектно-ориентированным программированием.

             * Создав класс можно создать его экземпляр — объект.
             * Объект — это функционирующий прототип класса, которому можно задавать поля и вызывать методы.

             * Поля или свойства — это всё, что может хранить информацию, которую вы потом можете заполнять (переменные, массивы и т.д.).
             * Методы — это обычные функции, в функционале которых можно использовать поля.
             * Чтобы обратится к полям и методам класса нужно перед названием имени свойства поставить точку (.). */

            // Классы, как и структуры, прописываются до функции main. Также после каждого класса надо ставить точку с запятой (;).

            // По умолчанию поля класса являются приватными.

            // Объявление классов в С++:
                class cl {
                public:
                /* Список методов, доступных другим функциям и объектам программы,
                 * т.е. доступных вне используемого класса. */
                private:
                /* Список полей и методов для использования внутри класса,
                 * т.е. доступ к ним имеется только внутри данного класса. */
                protected:
                /* Список средств, доступных при наследовании,
                 * т.е. к этим средствам мы имеем доступ в этом классе, а также в классах-наследниках (рассмотрим позже). */
                };

            // Пример класса:
                class Car {
                private:
                    int height;
                    float speed;
                public:
                    void setValues(int height, float speed) {
                        this->height = height;
                        this->speed = speed;
                        /* Указатель this – это указатель, который хранит адрес конкретного объекта класса.
                         * Он присутствует в виде скрытого первого параметра в каждом методе класса (кроме статических методов).
                         * Типом этого указателя является имя класса. В методах класса, при необходимости, можно использовать this явно.
                         * Однако явно объявлять, инициализировать или изменять этот указатель, нет возможности. */
                    }
                    void print() {
                        cout << "Height: " << this->height << " / " << "Speed: " << this->speed << endl;
                    }
                    void change(int height, float speed);
                };

                // Определение методов вне класса
                    void Car::change(int height, float speed) {
                        this->height += height;
                        this->speed += speed;
                    }

                int main() {
                    Car toyota;
                    toyota.setValues(2, 200.15);
                    toyota.print(); // Выведется "Height: 2 / Speed: 200.15".

                    Car mitsubishi;
                    mitsubishi.setValues(1, 210.001);
                    mitsubishi.print(); // Выведется "Height: 1 / Speed: 210.001".
                }

        }

        { // Конструкторы и деструкторы

            /* Конструктор - это особый метод класса, который выполняется автоматически в момент создания объекта класса.
             * То есть, если мы пропишем в нем, какими значениями надо инициализировать поля во время объявления объекта класса,
             * он сработает без “особого приглашения”. Его не надо специально вызывать, как обычный метод класса. */

            /* Деструктор - так же особый метод класса, который срабатывает во время уничтожения объектов класса.
             * Чаще всего его роль заключается в том, чтобы освободить динамическую память, которую выделял конструктор для объекта.
             * Имя его, как и у конструктора, должно соответствовать имени класса. Только перед именем надо добавить символ "~". */

            // Пример:
                class Car {
                private:
                    int height = 0;
                    float speed = 0;
                    int size = 0;
                    int* numbers;
                public:
                    Car() {} // Конструктор по умолчанию

                    /* Конструктор по умолчанию – это конструктор класса, который объявляется без параметров.
                     * Если класс не содержит явным образом определенный конструктор,
                     * тогда при создании объекта автоматически вызывается конструктор по умолчанию. */

                    Car(int height, float speed, int size) {
                        this->height = height;
                        this->speed = speed;
                        this->size = size;
                        this->numbers = new int[size];
                        for(int i = 0; i < size; i++) {
                            numbers[i] = i;
                        }
                        print();
                    } // Конструктор

                    Car(const Car &a) {
                        this->height = a.height;
                        this->speed = a.speed;
                        this->size = a.size;

                        this->numbers = new int[a.size];
                        for(int i = 0; i < a.size; i++) {
                            this->numbers[i] = a.numbers[i];
                        }
                    } // Конструктор копирования

                    /* Конструктор копирования нужен нам для того,
                     * чтобы создавать «реальные» копии объектов класса, а не побитовую копию объекта. */

                    Car(Car &&a) {
                        this->height = a.height;
                        this->speed = a.speed;
                        this->size = a.size;

                        this->numbers = new int[a.size];
                        for(int i = 0; i < a.size; i++) {
                            this->numbers[i] = a.numbers[i];
                        }

                        a.height = 0;
                        a.speed = 0;
                        a.size = 0;
                        delete[] a.numbers;
                    } // Конструктор перемещения

                    /* Конструктор перемещения позволяет переместить объект
                     * вместо его копирования для увеличения производительности. */

                    void setValues(int height, float speed) {
                        this->height = height;
                        this->speed = speed;
                    }

                    void print() {
                        cout << "Height: " << this->height << " / " << "Speed: " << this->speed << endl;
                    }

                    ~Car() {
                        cout << "Work ended" << endl;
                    } // Деструктор
                };

                int main() {
                    Car toyota(2, 200.15, {1, 2, 3}, 3); // Используем новый, описанный нами конструктор. Выведется "Height: 2 / Speed: 200.15".

                    Car mitsubishi; // Используем конструктор по умолчанию
                    mitsubishi.setValues(1, 210.001);
                    mitsubishi.print(); // Выведется "Height: 1 / Speed: 210.001".

                    /* Деструкторы срабатывают после того, как мы завершили работу с классом.
                     * В данном случае "Work ended" выведется 2 раза подряд в конце. */
                }
        }

        { // Наследование классов

            // Выше я уже описал, что из себя представляет наследование, как один из принципов ООП.

            // Пример наследования класса:
            class Car {
            protected:
                int height;
                float speed;
            public:
                Car() {
                    cout << "Car constructor called" << endl;
                    this->height = 3;
                    this->speed = 501.12;
                }
                Car(int height, float speed) {
                    this->height = height;
                    this->speed = speed;
                }
                void setValues(int height, float speed) {
                    this->height = height;
                    this->speed = speed;
                }
                void print() {
                    cout << "Height: " << this->height << " / " << "Speed: " << this->speed << endl;
                }
                ~Car() {
                    cout << "Car destructor called" << endl;
                }
            };

            class Motorcycle: public Car {

           /* Теперь мы имеем доступ ко всем методам в public из класса Car, кроме конструкторов и деструкторов.
            * Однако они вызываются, когда дочерний класс инициализирует свой объект.
            * Конструкторы вызываются один за другим иерархически, начиная с базового класса и заканчивая последним производным классом.
            * Деструкторы вызываются в обратном порядке. */

            public:
                Motorcycle() {
                    cout << "Motorcycle constructor called" << endl;
                }
                ~Motorcycle() {
                    cout << "Motorcycle destructor called" << endl;
                }
                void print() {
                    cout << "Height: " << this->height << " / " << "Speed: " << this->speed << endl;
                }
            };

            int main() {
                Motorcycle bmw; // Путь конструктора: Car -> Motorcycle.
                bmw.setValues(10, 210.2); // Вызвали функцию из суперкласса Car.
                bmw.print(); // Вызовется функция из класса Motorcycle.
                    // Чтобы вызвать функцию с тем же названием из Car, надо написать:
                        bmw.Car::print();
                // Путь деструктора: Motorcycle -> Car.
            }

            // Множественное наследование:
                class Supplies {
                protected:
                    float weight;
                public:
                    void setWeight(float weight) {
                        this->weight = weight;
                    }
                    void print() {
                        cout << "Weight is: " << weight << endl;
                    }
                };
                class Truck: public Car, public Supplies {};

                int main() {
                    Truck mercedes;
                    mercedes.setWeight(1602.78); // Используем метод из класса Supplies
                    mercedes.setValues(7, 102.2); // Используем метод из класса Car
                }

                /* Множественное наследование требует тщательного проектирования, так как может привести к непредвиденным последствиям.
                 * Большинство таких последствий вызваны неоднозначностью в наследовании.
                 * В данном примере Truck наследует метод print() от обоих родителей и неясно какой метод должен быть вызван. */
        }

        { // Дружественные функции

            // Дружественные функции - это функции, которые не являются членами класса,
            // однако имеют доступ к его закрытым членам - переменным и функциям, которые имеют спецификатор private.

            // Для определения дружественных функций используется ключевое слово friend.

                class Person {
                private:
                    int height_in_m;
                    int weight_in_kg;
                public:
                    friend double body_mass_index(const Person&);
                };

                double body_mass_index(const Person& person) {
                    return person.weight_in_kg / pow(person.height_in_m, 2);
                }

            // Определение дружественных функций в классе

                // Дружественные функции могут определяться в другом классе:
                    class Car;
                    class Man {
                    public:
                        Man();
                        void drive(Car&);
                        void setPrice(Car&, int);
                    private:
                        std::string name;
                    };
                    class Car {
                        friend void Man::drive(Car&);
                        friend void Man::setPrice(Car&, int price);
                    public:
                        Car();
                        std::string getName() { return name; }
                        int getPrice() { return price; }
                    private:
                        std::string name;
                        int price;
                    };
                    void Man::drive(Car &a) {
                        std::cout << name << " drives " << a.name << std::endl;
                    }
                    void Man::setPrice(Car &a, int price) {
                        if(price > 0)
                            a.price = price;
                    }

            // Дружественные классы

                // В случае выше класс Man использует только две функции из класса Car.
                // Но допустим, что впоследствии возникла необходимость добавить в класс Car
                // еще ряд дружественных функций, которые будут определены в классе Man,
                // либо мы можем предполагать, что класс Man будет активно использовать объекты Car.
                // И в этом случае целесообразно определять не отдельные дружественные функции,
                // а определить дружественным весь класс Man:

                    class Man;
                    class Car {
                        friend class Man;
                        ...
                    };
                    // То есть тем самым мы опять же говорим, что класс Man - это друг класса Car,
                    // поэтому объекты Man могут обращаться к приватным переменным класса Car.
                    // После этого в классе Man можно обращаться к закрытым членам класса Car из любых функций.
        }

        { // Перегрузка функций

            // Функции (а также шаблоны функций) называются перегруженными (overloaded),
            // если они объявлены в одной области видимости и имеют одно и то же имя.
            // Перегруженные функции не могут иметь разные типы возвращаемого значения,
            // спецификатор исключений или спецификатор удаленной функции (= delete) при одинаковых параметрах.

            void Foo();
            char Foo(); // ошибка

            void Foo(int x);
            void Foo(int x) noexcept;  // ошибка
                // Спецификатор noexcept даёт гарантию того, что в коде функция точно не генерирует исключений.

            void Foo(double x);
            void Foo(double) = delete; // ошибка
                // Спецификатор delete помечает функцию как удалённую, и любое обращение к ней будет вызывать ошибку компиляции.

            // Перегрузка операторов

                // Перегрузка операторов позволяет определить действия, которые будет выполнять оператор.
                // Перегрузка подразумевает создание функции, название которой содержит слово operator и символ перегружаемого оператора.
                // Функция оператора может быть определена как член класса, либо вне класса.

                    class Integer {
                    public:
                        Integer operator+=(const Integer&);
                    };

                    Integer Integer::operator+=(const Integer& a){
                        return *this + a;
                    }
        }

        {

        }

    }

    return 0; // Показывает, что функция main завершилась успешно. Во многих компиляторах производится автоматически.
}
